import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/announcement.dart';
import '../models/assignment.dart';
import '../models/session.dart';
import 'announcement_service.dart';

/// Service for generating dynamic announcements based on sessions and assignments
class DynamicAnnouncementService {
  final AnnouncementService _announcementService;
  final FirebaseFirestore _firestore;

  DynamicAnnouncementService({
    AnnouncementService? announcementService,
    FirebaseFirestore? firestore,
  })  : _announcementService = announcementService ?? AnnouncementService(),
        _firestore = firestore ?? FirebaseFirestore.instance;

  /// Generate announcements for upcoming sessions and assignments
  /// This should be called periodically or when data changes
  Future<void> generateAnnouncementsForUser(String userId) async {
    final now = DateTime.now();

    // Get upcoming sessions (next 7 days)
    final upcomingSessions = await _getUpcomingSessions(userId, 7);

    // Get upcoming assignments (next 7 days)
    final upcomingAssignments = await _getUpcomingAssignments(userId, 7);

    // Generate session announcements
    for (final session in upcomingSessions) {
      await _generateSessionAnnouncement(session, userId, now);
    }

    // Generate assignment announcements
    for (final assignment in upcomingAssignments) {
      await _generateAssignmentAnnouncement(assignment, userId, now);
    }
  }

  /// Generate announcement for a session
  Future<void> _generateSessionAnnouncement(
    Session session,
    String userId,
    DateTime now,
  ) async {
    final sessionDateTime = DateTime(
      session.date.year,
      session.date.month,
      session.date.day,
      session.startTime.hour,
      session.startTime.minute,
    );

    final hoursUntil = sessionDateTime.difference(now).inHours;

    // Only create announcements for sessions within 24 hours
    if (hoursUntil <= 24 && hoursUntil > 0) {
      String title;
      String description;
      String priority;

      if (hoursUntil <= 1) {
        title = 'ðŸ”” Session Starting Soon!';
        description =
            '${session.title} (${session.course}) starts in less than 1 hour at ${session.location}';
        priority = 'high';
      } else if (hoursUntil <= 3) {
        title = 'â° Upcoming Session';
        description =
            '${session.title} (${session.course}) starts in $hoursUntil hours at ${session.location}';
        priority = 'high';
      } else {
        title = 'ðŸ“… Session Today';
        description =
            '${session.title} (${session.course}) is scheduled for today at ${_formatTime(session.startTime)} at ${session.location}';
        priority = 'medium';
      }

      // Check if announcement already exists for this session
      final existingAnnouncement =
          await _findExistingSessionAnnouncement(userId, session.id);

      if (existingAnnouncement == null) {
        final announcement = Announcement(
          id: '', // Will be generated by Firestore
          userId: userId,
          title: title,
          description: description,
          createdAt: now,
          expiresAt: sessionDateTime.add(const Duration(hours: 2)),
          priority: priority,
          isRead: false,
        );

        await _announcementService.createAnnouncement(announcement);
      }
    }
  }

  /// Generate announcement for an assignment
  Future<void> _generateAssignmentAnnouncement(
    Assignment assignment,
    String userId,
    DateTime now,
  ) async {
    if (assignment.isCompleted) return;

    final hoursUntil = assignment.dueDate.difference(now).inHours;

    // Only create announcements for assignments within 48 hours
    if (hoursUntil <= 48 && hoursUntil > 0) {
      String title;
      String description;
      String priority;

      if (hoursUntil <= 6) {
        title = 'ðŸš¨ Assignment Due Very Soon!';
        description =
            '${assignment.title} (${assignment.course}) is due in less than 6 hours!';
        priority = 'high';
      } else if (hoursUntil <= 24) {
        title = 'âš ï¸ Assignment Due Tomorrow';
        description =
            '${assignment.title} (${assignment.course}) is due in ${(hoursUntil / 24).ceil()} day(s)';
        priority = 'high';
      } else {
        title = 'ðŸ“ Upcoming Assignment';
        description =
            '${assignment.title} (${assignment.course}) is due in ${(hoursUntil / 24).ceil()} days';
        priority = 'medium';
      }

      // Check if announcement already exists for this assignment
      final existingAnnouncement =
          await _findExistingAssignmentAnnouncement(userId, assignment.id);

      if (existingAnnouncement == null) {
        final announcement = Announcement(
          id: '', // Will be generated by Firestore
          userId: userId,
          title: title,
          description: description,
          createdAt: now,
          expiresAt: assignment.dueDate.add(const Duration(hours: 1)),
          priority: priority,
          isRead: false,
        );

        await _announcementService.createAnnouncement(announcement);
      }
    }
  }

  /// Get upcoming sessions for a user
  Future<List<Session>> _getUpcomingSessions(String userId, int days) async {
    final now = DateTime.now();
    final endDate = now.add(Duration(days: days));

    final snapshot = await _firestore
        .collection('sessions')
        .where('userId', isEqualTo: userId)
        .where('date', isGreaterThanOrEqualTo: Timestamp.fromDate(now))
        .where('date', isLessThanOrEqualTo: Timestamp.fromDate(endDate))
        .get();

    return snapshot.docs.map((doc) => Session.fromFirestore(doc)).toList();
  }

  /// Get upcoming assignments for a user
  Future<List<Assignment>> _getUpcomingAssignments(
      String userId, int days) async {
    final now = DateTime.now();
    final endDate = now.add(Duration(days: days));

    final snapshot = await _firestore
        .collection('assignments')
        .where('userId', isEqualTo: userId)
        .where('isCompleted', isEqualTo: false)
        .where('dueDate', isGreaterThanOrEqualTo: Timestamp.fromDate(now))
        .where('dueDate', isLessThanOrEqualTo: Timestamp.fromDate(endDate))
        .get();

    return snapshot.docs.map((doc) => Assignment.fromFirestore(doc)).toList();
  }

  /// Find existing session announcement
  Future<Announcement?> _findExistingSessionAnnouncement(
    String userId,
    String sessionId,
  ) async {
    final snapshot = await _firestore
        .collection('announcements')
        .where('userId', isEqualTo: userId)
        .where('description', isGreaterThanOrEqualTo: sessionId)
        .limit(1)
        .get();

    if (snapshot.docs.isEmpty) return null;
    return Announcement.fromFirestore(snapshot.docs.first);
  }

  /// Find existing assignment announcement
  Future<Announcement?> _findExistingAssignmentAnnouncement(
    String userId,
    String assignmentId,
  ) async {
    final snapshot = await _firestore
        .collection('announcements')
        .where('userId', isEqualTo: userId)
        .where('description', isGreaterThanOrEqualTo: assignmentId)
        .limit(1)
        .get();

    if (snapshot.docs.isEmpty) return null;
    return Announcement.fromFirestore(snapshot.docs.first);
  }

  /// Format TimeOfDay to string
  String _formatTime(dynamic time) {
    if (time == null) return '';
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}
